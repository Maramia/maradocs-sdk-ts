import { z } from "zod";

// ============================================================================
// Common Primitive Schemas
// ============================================================================

/**
 * UUID identifier - standardized on z.guid() throughout the codebase
 */
export const UUIDSchema = z.guid();
export type UUID = z.infer<typeof UUIDSchema>;

/**
 * Non-negative integer (>= 0) - equivalent to Pydantic's NonNegativeInt
 */
export const NonNegativeIntSchema = z.number().int().min(0);
export type NonNegativeInt = z.infer<typeof NonNegativeIntSchema>;

/**
 * Positive integer (>= 1) - equivalent to Pydantic's PositiveInt
 */
export const PositiveIntSchema = z.number().int().min(1);
export type PositiveInt = z.infer<typeof PositiveIntSchema>;

/**
 * ISO 8601 datetime string from API
 */
export const DateTimeSchema = z.iso.datetime();
export type DateTime = z.infer<typeof DateTimeSchema>;

/**
 * Base64 encoded binary data
 */
export const Base64BytesSchema = z.base64();
export type Base64Bytes = z.infer<typeof Base64BytesSchema>;

// ============================================================================
// Domain-Specific Schemas
// ============================================================================

/**
 * SHA-256 hash as a 64-character hexadecimal string
 */
export const Sha256Schema = z.string().regex(/^[0-9A-Fa-f]{64}$/).describe("SHA-256 hash as 64-character hex string");
export type Sha256 = z.infer<typeof Sha256Schema>;

/**
 * String with maximum length of 255 characters
 */
export const Str255Schema = z.string().max(255).describe("String with max 255 characters");
export type Str255 = z.infer<typeof Str255Schema>;

/**
 * Confidence score between 0.0 (no confidence) and 1.0 (full confidence)
 */
export const ConfidenceSchema = z.number().min(0.0).max(1.0).describe("Confidence score between 0.0 and 1.0");
export type Confidence = z.infer<typeof ConfidenceSchema>;

/**
 * Cryptographically signed hash for handle verification.
 * Never set this manually - it is generated by the server.
 */
export const SignedHashSchema = z.base64().describe("Cryptographic signature for handle verification");

/**
 * Discrete angle of rotation in degrees counter-clockwise.
 * Valid values: 0, 90, 180, 270
 */
export const DiscreteAngleSchema = z.union([
  z.literal(0),
  z.literal(90),
  z.literal(180),
  z.literal(270),
]).describe("Rotation angle in degrees counter-clockwise (0, 90, 180, 270)");
export type DiscreteAngle = z.infer<typeof DiscreteAngleSchema>;

/**
 * Handle to a file stored in the workspace object storage
 */
export const FileHandleSchema = z.object({
  reference: z.guid().describe("Reference to the file in object storage"),
  size: z.number().int().positive().describe("Size of the file in bytes"),
  expires_at: z.iso.datetime().describe("Expiration date of the file handle"),
});
export type FileHandle = z.infer<typeof FileHandleSchema>;

/**
 * Handle to a file that has not been validated yet.
 * Must be validated before use in processing operations.
 */
export const UnvalidatedFileHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
}).describe("Handle to an unvalidated file");
export type UnvalidatedFileHandle = z.infer<typeof UnvalidatedFileHandleSchema>;

/**
 * Handle to a validated image file in the workspace
 */
export const ImgHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
  width: z.number().int().positive().describe("Width of the image in pixels"),
  height: z.number().int().positive().describe("Height of the image in pixels"),
}).describe("Handle to a validated image");
export type ImgHandle = z.infer<typeof ImgHandleSchema>;

/**
 * Size of a PDF page in millimeters
 */
export const PdfPageSizeSchema = z.object({
  width: z.number().int().positive().describe("Width of the page in mm"),
  height: z.number().int().positive().describe("Height of the page in mm"),
}).describe("PDF page size in millimeters");
export type PdfPageSize = z.infer<typeof PdfPageSizeSchema>;

/**
 * Metadata for a PDF page including size and rotation
 */
export const PdfPageMetadataSchema = z.object({
  page_size: PdfPageSizeSchema.describe("Size of the page"),
  rotation: DiscreteAngleSchema.describe("Rotation of the page"),
}).describe("PDF page metadata");
export type PdfPageMetadata = z.infer<typeof PdfPageMetadataSchema>;

/**
 * Handle to a validated PDF file in the workspace
 */
export const PdfHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
  pages: z.number().int().positive().describe("Number of pages in the PDF"),
}).describe("Handle to a validated PDF");
export type PdfHandle = z.infer<typeof PdfHandleSchema>;

/**
 * Handle to a PNG image in the workspace that can be downloaded
 */
export const PngHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
  width: z.number().int().positive().describe("Width of the image in pixels"),
  height: z.number().int().positive().describe("Height of the image in pixels"),
}).describe("Handle to a PNG image");
export type PngHandle = z.infer<typeof PngHandleSchema>;

/**
 * Handle to a JPEG image in the workspace that can be downloaded
 */
export const JpegHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
  width: z.number().int().positive().describe("Width of the image in pixels"),
  height: z.number().int().positive().describe("Height of the image in pixels"),
}).describe("Handle to a JPEG image");
export type JpegHandle = z.infer<typeof JpegHandleSchema>;

/**
 * Handle to an ODT (OpenDocument Text) file in the workspace
 */
export const OdtHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
  pages: z.number().int().positive().describe("Number of pages in the ODT"),
}).describe("Handle to an ODT file");
export type OdtHandle = z.infer<typeof OdtHandleSchema>;

/**
 * Handle to an HTML file in the workspace that can be downloaded
 */
export const HtmlHandleSchema = z.object({
  signed_hash: SignedHashSchema,
  file_handle: FileHandleSchema,
}).describe("Handle to an HTML file");
export type HtmlHandle = z.infer<typeof HtmlHandleSchema>;

/**
 * Image quality for PDF operations (1-100).
 * Higher values produce better quality but larger file sizes.
 */
export const PdfImgQualitySchema = z.number().int().min(1).max(100).describe("Image quality (1-100)");
export type PdfImgQuality = z.infer<typeof PdfImgQualitySchema>;

/**
 * Color mode settings for PDF image operations
 */
export const PdfImgColorSchema = z.enum([
  "original",
  "grayscale",
  "monochrome",
]).describe("Color mode: original, grayscale, or monochrome");
export type PdfImgColor = z.infer<typeof PdfImgColorSchema>;

/**
 * Dots per inch for image resolution (1-600).
 * Higher values produce more detailed images but larger file sizes.
 */
export const DPISchema = z.number().int().min(1).max(600).describe("DPI resolution (1-600)");
export type DPI = z.infer<typeof DPISchema>;

/**
 * Unique job identifier for async task tracking.
 * Can be UUID v7 or TigerBeetle ID depending on the context.
 */
export const JobIdSchema = z.string().min(1).max(128).describe("Unique job identifier");
export type JobId = z.infer<typeof JobIdSchema>;

/**
 * Response returned when creating an async task
 */
export const TaskCreatedResponseSchema = z.object({
  job_id: JobIdSchema.describe("Unique identifier for the created job"),
  milli_tokens_spent: z.number().int().positive().describe("Milli-tokens (1/1000th of a token) spent on task creation"),
}).describe("Response for async task creation");
export type TaskCreatedResponse = z.infer<typeof TaskCreatedResponseSchema>;
